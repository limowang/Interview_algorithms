# 数据库

## SQL

###  数据库分页

+ MySQL中，SELECT语句默认返回所有匹配的行 ，为了返回第一行或前几行，可使用**LIMIT子句**，以实现**分页查询** 

+ LIMIT语法

	+ ```sql
		-- 在所有的查询结果中，返回前5行记录。
		SELECT prod_name FROM products LIMIT 5;
		-- 在所有的查询结果中，从第5行开始，返回5行记录。
		SELECT prod_name FROM products LIMIT 5,5;
		```

	+ 优化LIMIT分页 

		偏移量过大时，可能要查询大半个表，代价很高，因此尽可能使用索引覆盖扫描，而不是查询所有的列，然后根据需要做一次关联操作再返回所需的列。

		```sql
		SELECT film_id,description FROM sakila.film ORDER BY title LIMIT 50,5;
		```

		如果表非常大，最好改写成  

		```sql
		SELECT film.film_id,film.description
		FROM sakila.film
		INNER JOIN (
		SELECT film_id FROM sakila.film ORDER BY title LIMIT 50,5
		) AS lim USING(film_id);
		```

		已知位置查询

		```sql
		SELECT film_id,description FROM skila.film
		WHERE position BETWEEN 50 AND 54 ORDER BY position;
		```

		对数据进行排名的问题也与此类似，但往往还会同时和GROUP BY混合使用，在这种情况下通常都需要预先计算并存储排名信息。  

		若需要按照租赁记录做翻页 ，向后回溯（倒序）

		```sql
		SELECT * FROM sakila.rental ORDER BY rental_id DESC LIMIT 20;
		```

		如果上面查询返回的是主键16049到16030的记录，那么下一页查询可从16030开始

		```sql
		SELECT * FROM sakila.rental
		WHERE rental_id < 16030 ORDER BY rental_id DESC LIMIT 20;
		```


### SQL中的聚合函数

+ COUNT()、AVG()、SUM()、MAX()、MIN()  

### 表跟表是怎么关联的？

+ 从语法上来说
	+ 内连接（INNER JOIN）：返回两张表中满足连接条件的数据 
	+ 外连接（OUTER JOIN）：返回两张表中满足连接条件的数据，同时返回不满足连接条件的数据 
		+ 左外连接：返回左表中的所有记录和右表中满足连接条件的记录  
		+ 右外连接：会返回右表中的所有记录和左表中满足连接条件的记录  
+ 从表的关系上来说
	+ 一对多关联：一般是两张表具有主从关系，并且以主表的主键关联从表的外键来实现这种关联关系  
	+ 多对多关联：如果两张表具有多对多的关系，那么它们之间需要有一张中间表来作为衔接，以实现这种关联关系  
	+ 自关联：自关联就是一张表自己与自己相关联，为了避免表名的冲突，需要在关联时通过别名将它们当做两张表来看待  

### SQL中怎么将行转成列

<img src="../../AppData/Roaming/Typora/typora-user-images/image-20230913141615642.png" alt="image-20230913141615642" style="zoom:25%;" /><img src="../../AppData/Roaming/Typora/typora-user-images/image-20230913141827116.png" alt="image-20230913141827116" style="zoom:25%;" />

+ 使用`CASE...WHEN...THEN` 语句实现行转列，参考如下代码：  

	```sql
	SELECT userid,
	SUM(CASE `subject` WHEN '语文' THEN score ELSE 0 END) as '语文',
	SUM(CASE `subject` WHEN '数学' THEN score ELSE 0 END) as '数学',
	SUM(CASE `subject` WHEN '英语' THEN score ELSE 0 END) as '英语',
	SUM(CASE `subject` WHEN '政治' THEN score ELSE 0 END) as '政治'
	FROM tb_score
	GROUP BY userid
	```

+ 使用 `IF()` 函数实现行转列，参考如下代码：  

	```sql
	SELECT userid,
	SUM(IF(`subject`='语文',score,0)) as '语文',
	SUM(IF(`subject`='数学',score,0)) as '数学',
	SUM(IF(`subject`='英语',score,0)) as '英语',
	SUM(IF(`subject`='政治',score,0)) as '政治'
	FROM tb_score
	GROUP BY userid
	```

### SQL注入

+ SQL注入的原理是将SQL代码伪装到输入参数中，传递到服务器解析并执行的一种攻击手法。  
+ 如何解决：
	+ 严格的参数校验  
	+ SQL预编译 

### 将一张表的部分数据更新到另一种表

+ 采用关联更新的方式， 参考如下代码：  

	```sql
	update b set b.col=a.col from a,b where a.id=b.id;
	update b set col=a.col from b inner join a on a.id=b.id;
	update b set b.col=a.col from b left Join a on b.id = a.id;
	```

### WHERE和HAVING的区别

+ WHERE：约束声明，使用WHERE约束来自数据库的数据，WHERE是在结果返回之前起作用的，WHERE中不能使用聚合函数  
+ HAVING：过滤声明，是在查询返回结果集以后对查询结果进行的过滤操作，在HAVING中可以使用聚合函数  
+ WHERE可以在执行分组操作和计算聚合函数之前过滤掉不需要的数据，性能会更好 

## 完整性约束

+ 概念：*==对表中的数据进行限定，保证数据的正确性、有效性和完整性。==*
+ 数据完整性约束包括：
	+ 定义**实体**完整性（主键约束、候选键（即唯一性）约束）
	+ 定义**参照**完整性（外键约束）
	+ 用户**定义**完整性（非空约束、默认值、自增等）

### 默认约束：default

+ 值为空时，使用默认值。关键字：`DEFAULT`

	```sql
	CREATE TABLE stu(
				id INT,
				height DOUBLE(3,2) DEFAULT 1.2 -- height不输入默认为1.2
			);
	```

### 非空约束：not null

+ 数据存入表时，保证值不为null。关键字：`NOT NULL`

	```sql
	CREATE TABLE stu(
				id INT,
				NAME VARCHAR(20) NOT NULL -- name为非空
			);
	```

### 唯一约束：unique

+ 数据存入表时，保证值唯一。关键字：`UNIQUE`

	```sql
	CREATE TABLE stu(
		id INT,
	    phone_number VARCHAR(20) UNIQUE --添加了唯一约束
	);
	```

### 主键约束：primary key

+ 唯一约束 + 非空约束，值唯一且不能为空。关键字：`primary key`

+ 一张表只能有一个字段为主键

+ 主键就是表中记录的唯一标识

	```sql
	CREATE TABLE stu(
		id INT PRIMARY KEY,  --给id添加主键约束
	    name VARCHAR(20)
	)
	```

### 外键约束：foreign key

+ 让表与表之间产生关系，从而保证数据的正确性。关键字：`foreign key`

	```sql
	create table 表名(
			....
			外键列
			constraint 外键名称 foreign key (外键列名称) references 主表名称(主表列名称)
	);
	```

## 索引

### 对MySQL索引的理解

+ 索引是一个单独的、存储在磁盘上的数据库结构，包含着对数据表里所有记录的引用指针（类似于数组的下标，哈希表的key）  
	+ 使用索引可以快速找出在某个或多个列中有一特定值的行，所有MySQL列类型都可以被索引  
+ 索引是在存储引擎中实现的 ，每种存储引擎的索引都不一定完全相同 ，每种存储引擎也不一定支持所有索引类型  
	+ MySQL中索引的存储类型有两种，即BTREE和HASH，具体和表的存储引擎相关。MyISAM和InnoDB存储引擎只支持BTREE索引；MEMORY/HEAP存储引擎可以支持HASH和BTREE索引。  
+ 索引的种类
	+ 普通索引（允许重复值和空值）和唯一索引（允许空值，但主键索引不允许空值）
	+ 单列索引（只包含单个列）和组合索引（多个字段组合 ，遵循最左前缀集合）
	+ 全文索引（CHAR、VARCHAR或者TEXT类型 ）  
	+ 空间索引 （对空间数据类型的字段GEOMETRY、POINT、LINESTRING和POLYGON ）
+ 索引的优点：
	+ 通过创建唯一索引，可以保证数据库表中每一行数据的唯一性
	+ 可以大大加快数据的查询速度，这也是创建索引的主要原因  
	+ 在实现数据的参考完整性方面，可以加速表和表之间的连接  
	+ 在使用分组和排序子句进行数据查询时，也可以显著减少查询中分组和排序的时间  

+ 索引的缺点：
	+ 创建索引和维护索引要耗费时间 
	+  索引需要占磁盘空间 
	+  当对表中的数据进行增加、删除和修改的时候，索引也要动态地维护  

### 如何创建及保护MySQL的索引

+ 在创建表的时候创建索引（不论创建哪种约束，在定义约束的同时相当于在指定列上创建了一个索引）  

	```
	CREATE TABLE table_name [col_name data_type]
	[UNIQUE|FULLTEXT|SPATIAL] [INDEX|KEY] [index_name] (col_name [length])
	[ASC|DESC]
	```

	例如，可以按照如下方式，在id字段上使用UNIQUE关键字创建唯一索引：  

	```sql
	CREATE TABLE t1 (
	    id INT NOT NULL,
	    name CHAR(30) NOT NULL,
	    UNIQUE INDEX UniqIdx(id)
	);
	```

+ 在已经存在的表中创建索引 ,可以使用ALTER TABLE语句或者CREATEINDEX语句 

	+ ALTER TABLE创建索引的基本语法如下：  

	```sql
	ALTER TABLE table_name ADD
	[UNIQUE|FULLTEXT|SPATIAL] [INDEX|KEY] [index_name] (col_name[length],...)
	[ASC|DESC]
	```

	例如，可以按照如下方式，在bookId字段上建立名称为UniqidIdx的唯一索引：  

	```sql
	ALTER TABLE book ADD UNIQUE INDEX UniqidIdx (bookId);
	```

	+ CREATE INDEX创建索引的基本语法如下：  

	```sql
	CREATE [UNIQUE|FULLTEXT|SPATIAL] INDEX index_name
	ON table_name (col_name [length],...) [ASC|DESC]
	```

	例如，可以按照如下方式，在bookId字段上建立名称为UniqidIdx的唯一索引：  

	```sql
	CREATE UNIQUE INDEX UniqidIdx ON book (bookId);
	```

### 只要创建了索引，就一定会走索引吗？  

+ 不一定。比如，在使用组合索引的时候，如果没有遵从“最左前缀”的原则进行搜索，则索引是不起作用的。  
+ 举例，假设在id、name、age字段上已经成功建立了一个名为MultiIdx的组合索引。索引行中按id、name、age的顺序存放，索引可以搜索id、（id,name）、（id, name, age）字段组合。如果列不构成索引最左面的前缀，那么MySQL不能使用局部索引，如（age）或者（name,age）组合则不能使用该索引查询。  

### 如何判断数据库的索引有没有生效？  

+ 可以使用EXPLAIN语句查看索引是否正在使用。  

​	举例，假设已经创建了book表，并已经在其year_publication字段上建立了普通索引。执行如下语句：  

```sql
EXPLAIN SELECT * FROM book WHERE year_publication=1990;
```

EXPLAIN语句将为我们输出详细的SQL执行信息，其中：  

- possible_keys行给出了MySQL在搜索数据记录时可选用的各个索引。
- key行是MySQL实际选用的索引。  

如果possible_keys行和key行都包含year_publication字段，则说明在查询时使用了该索引。

### 如何评估一个索引创建的是否合理  

建议按照如下的原则来设计索引：

- 避免对经常更新的表进行过多的索引，并且索引中的列要尽可能少。应该经常用于查询的字段创建索引，但要避免添加不必要的字段。
- 数据量小的表最好不要使用索引，由于数据较少，查询花费的时间可能比遍历索引的时间还要短，索引可能不会产生优化效果。
- 在条件表达式中经常用到的不同值较多的列上建立索引，在不同值很少的列上不要建立索引。
- 当唯一性是某种数据本身的特征时，指定唯一索引。使用唯一索引需能确保定义的列的数据完整性，以提高查询速度。
- 在频繁进行排序或分组的列上建立索引，如果待排序的列有多个，可以在这些列上建立组合索引。  

### 索引是越多越好吗？  

+ 索引并非越多越好，一个表中如有大量的索引，不仅占用磁盘空间，还会影响INSERT、DELETE、UPDATE等语句的性能，因为在表中的数据更改时，索引也会进行调整和更新。  

### 怎么避免索引失效

+ 使用组合索引时，需要遵循“最左前缀”原则；  
+ 不在索引列上做任何操作，例如计算、函数、类型转换，会导致索引失效而转向全表扫描；
+ 尽量使用覆盖索引（访问索引列的查询），减少 select * 覆盖索引能减少回表次数；
+ MySQL在使用不等于（!=或者<>）的时候无法使用索引会导致全表扫描；
+ LIKE以通配符开头（%abc）MySQL索引会失效变成全表扫描的操作；
+ 字符串不加单引号会导致索引失效（可能发生了索引列的隐式转换）；
+ 少用or，用它来连接时会索引失效。  

### 所有的字段都适合创建索引吗？  

下列几种情况，是不适合创建索引的：  

- 频繁更新的字段不适合建立索引；
- where条件中用不到的字段不适合建立索引；
- 数据比较少的表不需要建索引；
- 数据重复且分布比较均匀的的字段不适合建索引，例如性别、真假值；
- 参与列计算的列不适合建索引。  

### 索引的实现原理

+ MyISAM索引实现  

	+ MyISAM引擎使用B+Tree作为索引结构，叶节点的data域存放的是数据记录的地址 

	+ 主索引和辅助索引在结构上没有任何区别，只是主索引要求key是唯一的，而辅助索引的key可以重复。  

		<img src="../../AppData/Roaming/Typora/typora-user-images/image-20230913163547550.png" alt="image-20230913163547550"  />

+ InnoDB索引实现 
	+ InnoDB也使用B+Tree作为索引结构，但具体实现方式却与MyISAM截然不同  
		+ InnoDB的数据文件本身就是索引文件 ，而MyISAM索引文件和数据文件是分离的，索引文件仅保存数据记录的地址  
		+ InnoDB的所有辅助索引都引用主键作为data域 

<img src="../../AppData/Roaming/Typora/typora-user-images/image-20230913164046864.png" alt="image-20230913164046864" style="zoom: 50%;" />

### 索引重构

+ 什么时候需要重建索引呢？  

	- 表上频繁发生update,delete操作；

	- 表上发生了alter table ..move操作（move操作导致了rowid变化）。  

+ 怎么判断索引是否应该重建？  

	+ 一般看索引是否倾斜的严重，是否浪费了空间，对索引进行结构分析 

		```sql
		analyze index index_name validate structure;
		```

	+ 在相同的session中查询index_stats表  

		```sql
		select height,DEL_LF_ROWS/LF_ROWS from index_stats;
		```

​	当查询的height>=4（索引的深度，即从根到叶节点的高度）或DEL_LF_ROWS/LF_ROWS>0.2的情况下，就应该考虑重建该索引。 

+ 如何重建索引？  

	+ drop原索引，然后再创建索引（非常耗时，不推荐）

		```sql
		drop index index_name;
		create index index_name on table_name (index_column);
		```

	+ 直接重建索引（很快，推荐）

		```sql
		alter index indexname rebuild;
		alter index indexname rebuild online;
		```

	+ 重建索引过程中的注意事项 ：

		+ 执行rebuild操作时，需要检查表空间是否足够；

		+ 虽然说rebuild online操作允许DML操作，但还是建议在业务不繁忙时间段进行；

		+ Rebuild操作会产生大量Redo Log  

### MySQL的索引为什么用B+树？  

+ B+树由B树和索引顺序访问方法演化而来，它是为磁盘或其他直接存取辅助设备设计的一种平衡查找树，在B+树中，所有记录节点都是按键值的大小顺序存放在同一层的叶子节点，各叶子节点通过指针进行链接。B+树索引在数据库中的一个特点就是高扇出性 。  

	![image-20230913182941206](../../AppData/Roaming/Typora/typora-user-images/image-20230913182941206.png)

### 联合索引的存储结构是什么，它的有效方式是什么？  

+ 联合索引是指对表上的多个列进行索引，联合索引的创建方法与单个索引创建的方法一样，不同之处仅在于有多个索引列。  
+ 从本质上来说，联合索引还是一棵B+树，不同的是联合索引的键值数量不是1，而是大于等于2。另外，只有在查询条件中使用了这些字段的左边字段时，索引才会被使用，所以使用联合索引时遵循最左前缀集合。  

![image-20230913183452587](../../AppData/Roaming/Typora/typora-user-images/image-20230913183452587.png)

### MySQL的Hash索引和B+树索引有什么区别  

+ hash索引底层就是hash表，进行查找时，调用一次hash函数就可以获取到相应的键值，之后进行回表查询获得实际数据。  
+ B+树底层实现是多路平衡查找树，对于每一次的查询都是从根节点出发，查找到叶子节点方可以获得所查键值，然后根据查询判断是否需要回表查询数据。  
+ 两者的区别：
	+ hash索引进行等值查询更快(一般情况下)，但是却无法进行范围查询。  
	+ hash索引不支持使用索引进行排序  
	+ hash索引不支持模糊查询以及多列索引的最左前缀匹配，原理也是因为hash函数的不可预测  
	+ hash索引任何时候都避免不了回表查询数据，而B+树在符合某些条件(聚簇索引，覆盖索引等)的时候可以只通过索引完成查询。 
	+ hash索引虽然在等值查询上较快，但是不稳定，性能不可预测。而B+树的查询效率比较稳定，对于所有的查询都是从根节点到叶子节点，且树的高度较低  
+ 在大多数情况下，直接选择B+树索引可以获得稳定且较好的查询速度 。

### 聚簇索引和非聚簇索引有什么区别？  

+ 在InnoDB存储引擎中，可以将B+树索引分为聚簇索引和辅助索引（非聚簇索引）。无论是何种索引，每个页的大小都为16KB，且不能更改。  

+ 聚簇索引是根据主键创建的一棵B+树，聚簇索引的叶子节点存放了表中的所有记录。  
+ 辅助索引是根据索引键创建的一棵B+树，与聚簇索引不同的是，其叶子节点仅存放索引键值，以及该索引键值指向的主键。 
+ 如果通过辅助索引来查找数据，那么当找到辅助索引的叶子节点后，很有可能还需要根据主键值查找聚簇索引来得到数据，这种查找方式又被称为书签查找 。

### select in语句中如何使用索引？  

+ 索引是否起作用，主要取决于字段类型 :
	+ 如果字段类型为字符串，需要给in查询中的数值与字符串值都需要添加引号，索引才能起作用。  
	+ 如果字段类型为int，则in查询中的值不需要添加引号，索引也会起作用。  

### 模糊查询语句中如何使用索引？  

+ 在MySQL中模糊查询 mobile like ‘%8765’ ，这种情况是不能使用 mobile 上的索引的 ，我们可以加入冗余列，根据手机号码后四位进行模糊查询 ，比如mobile_reverse，内部存储为 mobile 的倒叙文本，为 mobile_reverse 列建立索引，查询中使用语句mobile_reverse likereverse(’%5678’) 即可 。

## 事务

### 对数据库事务的了解  

+ 概念：事务可由一条非常简单的SQL语句组成，也可以由一组复杂的SQL语句组成。
+ 在事务中的操作，要么都执行修改，要么都不执行，这就是事务的目的，也是事务模型区别于文件系统的重要特征之一 。
+ ACID四个特性：
	+ A（atomicity），原子性。原子性指整个数据库事务是不可分割的工作单位。只有使事务中所有的数据库操作都执行成功，整个事务的执行才算成功。  
	+ 原子性实现原理
		+ 实现原子性的关键，是当事务回滚时能够撤销所有已经成功执行的sql语句。  
		+ InnoDB实现回滚靠的是undo log（逻辑日志，记录sql执行的相关信息），当事务对数据库进行修改时，InnoDB会生成对应的undo log。  
		+ 如果事务执行失败或调用了rollback，导致事务需要回滚，便可以利用undo log中的信息将数据回滚到修改之前的样子。 
	+ C（consistency），一致性。一致性指事务将数据库从一种状态转变为另一种一致的状态。在事务开始之前和事务结束以后，数据库的完整性约束没有被破坏。一致性是事务追求的最终目标 ，原子性、持久性和隔离性，都是为了保证数据库状态的一致性。  
	+ 一致性实现原理
		+ 保证原子性、持久性和隔离性，如果这些特性无法保证，事务的一致性也无法保证。  
		+ 数据库本身提供保障  
		+ 应用层面进行保障  
	+ I（isolation），隔离性。事务的隔离性要求每个读写事务的对象与其他事务的操作对象能相互分离，即该事务提交前对其他事务都不可见，这通常使用锁来实现。 
	+ 隔离性实现原理
		+ 隔离性追求的是并发情形下事务之间互不干扰，目前主要考虑最简单的读操作和写操作  
		+ 第一方面，(一个事务)写操作对(另一个事务)写操作的影响：锁机制保证隔离性。  
			+ 按照粒度，锁可以分为表锁、行锁以及其他位于二者之间的锁。  
			+ 表锁在操作数据时会锁定整张表，并发性能较差。行锁则只锁定需要操作的数据，并发性能好。
			+ 但是由于加锁本身需要消耗资源，因此在锁定数据较多情况下使用表锁可以节省大量资源。  
			+ MyIsam只支持表锁，而InnoDB同时支持表锁和行锁 。出于性能考虑，绝大多数情况下使用的都是行锁。
		+ 第二方面，(一个事务)写操作对(另一个事务)读操作的影响：MVCC保证隔离性。
			+  InnoDB默认的隔离级别是RR（REPEATABLE READ），RR解决脏读、不可重复读、幻读等问题，使用的是MVCC（Multi-Version Concurrency Control，即多版本的并发控制协议  ），它最大的优点是读不加锁，因此读写不冲突，并发性能好 。
			+ 主要基于以下技术及数据结构： 隐藏列、基于undo log的版本链、ReadView
	+ D（durability） ，持久性。事务一旦提交，其结果就是永久性的，即使发生宕机等故障，数据库也能将数据恢复。持久性保证的是事务系统的高可靠性，而不是高可用性。 
	+ 持久性实现原理
		+ InnoDB作为MySQL的存储引擎，数据是存放在磁盘中的，但如果每次读写数据都需要磁盘IO，效率会很低。  为此，InnoDB提供了缓存(Buffer Pool)，Buffer Pool中包含了磁盘中部分数据页的映射，作为访问数据库的缓冲。  
		+ 如果MySQL宕机，而此时Buffer Pool中修改的数据还没有刷新到磁盘，就会导致数据的丢失，事务的持久性无法保证。  
		+ redo log（预写式日志，所有修改先写入日志，再更新到Buffer Pool）被引入来解决这个问题。当数据修改时，除了修改Buffer Pool中的数据，还会在redo log记录这次操作。当事务提交时，会调用fsync接口对redo log进行刷盘。如果MySQL宕机，重启时可以读取redo log中的数据，对数据库进行恢复。 

+ 事务类型
	+ 扁平事务 ：在扁平事务中，所有操作都处于同一层次，其由BEGIN WORK开始，由COMMIT WORK或ROLLBACK WORK结束。处于之间的操作是原子的，要么都执行，要么都回滚。 
	+ 带有保存点的扁平事务  ：除了支持扁平事务支持的操作外，允许在事务执行过程中回滚到同一事务中较早的一个状态  。保存点（savepoint）用来通知系统应该记住事务当前的状态，以便以后发生错误时，事务能回到该状态。
	+   链事务  ：可视为保存点模式的一个变种 。链事务的思想是：在提交一个事务时，释放不需要的数据对象，将必要的处理上下文隐式地传给下一个要开始的事务。  
	+ 嵌套事务：是一个层次结构框架。有一个顶层事务（top-level transaction）控制着各个层次的事务。顶层事务之下嵌套的事务被称为子事务（subtransaction），其控制每一个局部的变换。  
	+ 分布式事务：通常是一个在分布式环境下运行的扁平事务，因此需要根据数据所在位置访问网络中的不同节点。对于分布式事务，同样需要满足ACID特性，要么都发生，要么都失效。  
	+ 对于MySQL的InnoDB存储引擎来说，它支持扁平事务、带有保存点的扁平事务、链事务、分布式事务。对于嵌套事务，MySQL数据库并不是原生的，因此对于有并行事务需求的用户来说MySQL就无能为力了，但是用户可以通过带有保存点的事务来模拟串行的嵌套事务。  

### MySQL的事务隔离级别及实现机制

+ 并发情况下，读操作可能存在的三类问题：  
	+ 脏读：当前事务(A)中可以读到其他事务(B)未提交的数据（脏数据）  
	+ 不可重复读：在事务A中先后两次读取同一个数据，两次读取的结果不一样（数据变了）  
	+ 幻读：在事务A中按照某个条件先后两次查询数据库，两次查询结果的条数不同 （数据的行数变了）

+ 事务隔离是为了解决脏读、不可重复读、幻读问题，下表展示了 4 种隔离级别对这三个问题的解决程度：  

|          ==隔离级别==           | ==脏读== | ==不可重复读== | ==幻读== |
| :-----------------------------: | :------: | :------------: | :------: |
|   读未提交(READ UNCOMMITTED )   |   可能   |      可能      |   可能   |
|     读提交(READ COMMITTED)      |  不可能  |      可能      |   可能   |
| 可重复读(REPEATABLE READ，默认) |  不可能  |     不可能     |  不可能  |
|      串行化(SERIALIZABLE)       |  不可能  |     不可能     |  不可能  |

+ READ UNCOMMITTED & READ COMMITTED：通过Record Lock算法实现了行锁，但READ UNCOMMITTED允许读取未提交数据，所以存在脏读问题。而READ COMMITTED允许读取提交数据，所以不存在脏读问题，但存在不可重复读问题。  

+ REPEATABLE READ：使用Next-Key Lock算法实现了行锁，并且不允许读取已提交的数据，所以解决了不可重复读的问题。另外，该算法包含了间隙锁，会锁定一个范围，因此也解决了幻读的问题。  
+ SERIALIZABLE：对每个SELECT语句后自动加上LOCK IN SHARE MODE，即为每个读取操作加一个共享锁。因此在这个事务隔离级别下，读占用了锁，对一致性的非锁定读不再予以支持。  

### MySQL事务如何回滚？  

+ 在MySQL默认的配置下，事务都是自动提交和回滚的。当显示地开启一个事务时，可以使用ROLLBACK语句进行回滚。  
	+ ROLLBACK：要使用这个语句的最简形式，只需发出ROLLBACK。回滚会结束用户的事务，并撤销正在进行的所有未提交的修改。  
	+ ROLLBACK TO [SAVEPOINT] identifier ：这个语句与SAVEPOINT命令一起使用。可以把事务回滚到标记点，而不回滚在此标记点之前的任何工作。  

## 锁

### 了解数据库的锁吗？  

+ 概念：锁是数据库系统区别于文件系统的一个关键特性，锁机制用于管理对共享资源的并发访问。

+ 锁的类型

	+ InnoDB存储引擎实现了如下两种标准的行级锁 ：

		+  共享锁（S Lock），允许事务读一行数据  

		+ 排他锁（X Lock），允许事务删除或更新一行数据。  

	+ 如果一个事务T1已经获得了行r的共享锁，那么事务T2可以立即获得行r的共享锁，因为读取并没有改变行r的数据，称这种情况为锁兼容。若事务T3想获得行r的排他锁，则其必须等待事务T1、T2释放行r上的共享锁，这种情况称为锁不兼容。 

	+ InnoDB存储引擎支持意向锁设计比较简练，其意向锁即为表级别的锁。设计目的主要是为了在一个事务中揭示下一行将被请求的锁类型。其支持两种意向锁：  

		+  意向共享锁（IS Lock），事务想要获得一张表中某几行的共享锁。  
		+  意向排他锁（IX Lock），事务想要获得一张表中某几行的排他锁。  

		![image-20230913210233656](../../AppData/Roaming/Typora/typora-user-images/image-20230913210233656.png)

+ 锁的算法
	+ InnoDB存储引擎有3种行锁的算法，其分别是： 
		+  Record Lock：单个行记录上的锁。  
		+ Gap Lock：间隙锁，锁定一个范围，但不包含记录本身。  
		+ Next-Key Lock∶Gap Lock+Record Lock，锁定一个范围，并且锁定记录本身。  

+ 关于死锁
	+ 死锁是指两个或两个以上的事务在执行过程中，因争夺锁资源而造成的一种互相等待的现象。若无外力作用，事务都将无法推进下去。  A等待B、B等待A，这种死锁问题被称为AB-BA死锁。  
	+ 死锁解决
		+ 超时：当两个事务互相等待时，当一个等待时间超过设置的某一阈值时，其中一个事务进行回滚，另一个等待的事务就能继续进行。  
		+ wait-for graph（等待图）  ：当前普遍采用，要求数据库保存锁的信息链表 、事务等待链表，通过上述链表构建图，若图中存在环，则存在死锁  
+ 锁的升级：锁升级（Lock Escalation）是指将当前锁的粒度降低。  
	+ 举例来说，数据库可以把一个表的1000个行锁升级为一个页锁，或者将页锁升级为表锁。  
	+ InnoDB存储引擎不存在锁升级的问题，其根据每个事务访问的每个页对锁进行管理的，采用的是位图的方式。  

### InnoDB中行级锁是怎么实现的？  

+ InnoDB行级锁是通过给索引上的索引项加锁来实现的。只有通过索引条件检索数据，InnoDB才使用行级锁，否则，InnoDB将使用表锁。  

## 优化

### 对数据库优化的理解  

+ MySQL数据库优化是多方面的，原则是减少系统的瓶颈，减少资源的占用，增加系统的反应速度。  
	+ 针对查询，我们可以通过使用索引、使用连接（JOIN)代替子查询的方式来提高查询速度。 
	+ 针对慢查询，我们可以通过分析慢查询日志，来发现引起慢查询的原因，从而有针对性的进行优化。  
	+ 针对插入，我们可以通过禁用索引、禁用检查等方式来提高插入速度，在插入之后再启用索引和检查。  
	+ 针对数据库结构，我们可以通过将字段很多的表拆分成多张表、增加中间表、增加冗余字段等方式进行
		优化。  

### 表中包含几千万条数据怎么办

+ 建议按照如下顺序进行优化：

	- 优化SQL和索引；

	- 增加缓存，如memcached、redis；

	- 读写分离，可以采用主从复制，也可以采用主主复制；

	- 使用MySQL自带的分区表，这对应用是透明的，无需改代码，但SQL语句是要针对分区表做优化的；

	- 做垂直拆分，即根据模块的耦合度，将一个大的系统分为多个小的系统；

	- 做水平拆分，要选择一个合理的sharding key，为了有好的查询效率，表结构也要改动，做一定的

	- 冗余，应用也要改，sql中尽量带sharding key，将数据定位到限定的表上去查，而不是扫描全部的表。  

### 对explain的了解  

+ MySQL中提供了EXPLAIN语句和DESCRIBE语句，用来分析查询语句，EXPLAIN语句的基本语法如下：  

```sql
EXPLAIN [EXTENDED] SELECT select_options
```

+ 使用EXTENED关键字，EXPLAIN语句将产生附加信息。执行该语句，可以分析EXPLAIN后面SELECT语句的执行情况，并且能够分析出所查询表的一些特征。  
+ DESCRIBE语句的使用方法与EXPLAIN语句是一样的，分析结果也是一样的，并且可以缩写成DESC，DESCRIBE语句的语法形式如下：  

```sql
DESCRIBE SELECT select_options
```

### explain关注什么？  

|  列名   |                             备注                             |
| :-----: | :----------------------------------------------------------: |
|  type   |    本次查询表联接类型，从这里可以看到本次查询大概的效率。    |
|   key   |   最终选择的索引，如果没有索引的话，本次查询效率通常很差。   |
| key_len |             本次查询用于结果过滤的索引实际长度。             |
|  rows   |     预计需要扫描的记录数，预计需要扫描的记录数越小越好。     |
|  Extra  | 额外附加信息，主要确认是否出现 Using filesort、Using temporary 这两种情况。 |

## 其他

### 介绍一下数据库设计的三大范式

+ 目前关系数据库有六种范式，一般来说，数据库只需满足第三范式(3NF）就行了。  

	+ 第一范式（1NF）：属性不可分割   
	+ 第二范式（2NF）：在1NF基础上，不存在部分依赖（非主属性必须完全依赖于主属性） 
	+ 第三范式（3NF）：  在2NF基础上，任何非主属性不依赖于其它非主属性（在2NF基础上，不存在传递依赖）。  

	 <img src="../../AppData/Roaming/Typora/typora-user-images/image-20230913214635857.png" alt="image-20230913214635857" style="zoom:50%;" />

### 对MySQL引擎的了解  

+ 最常用的引擎是InnoDB和MyISAM。  

+ InnoDB是事务型数据库的首选引擎，支持事务安全表（ACID），支持行锁定和外键。MySQL 5.5.5之后，InnoDB作为默认存储引擎。
	+ InnoDB给MySQL提供了具有提交、回滚和崩溃恢复能力的事务安全（ACID兼容）存储引擎。  
	+ InnoDB是为处理巨大数据量的最大性能设计。  
	+ InnoDB存储引擎完全与MySQL服务器整合，为在主内存中缓存数据和索引而维持它自己的缓冲池。
	+ InnoDB支持外键完整性约束（FOREIGN KEY）。
	+ InnoDB被用在众多需要高性能的大型数据库站点上。  
+ MyISAM存储引擎基于ISAM存储引擎，并对其进行扩展。它是在Web、数据仓储和其他应用环境下最常使用的存
	储引擎之一。MyISAM拥有较高的插入、查询速度，但不支持事务。  
	+ 在支持大文件（达63位文件长度）的文件系统和操作系统上被支持。
	+ 当把删除和更新及插入操作混合使用的时候，动态尺寸的行产生更少碎片。
	+ 每个MyISAM表最大的索引数是64，这可以通过重新编译来改变。每个索引最大的列数是16个。
	+ 最大的键长度是1000B，这也可以通过编译来改变。
	+ BLOB和TEXT列可以被索引。
	+ NULL值被允许在索引的列中，这个值占每个键的0~1个字节。
	+ 所有数字键值以高字节优先被存储，以允许一个更高的索引压缩。
	+ 每个表一个AUTO_INCREMENT列的内部处理。
	+ 可以把数据文件和索引文件放在不同目录。
	+ 每个字符列可以有不同的字符集。
	+ 有VARCHAR的表可以固定或动态记录长度。
	+ VARCHAR和CHAR列可以多达64KB。  

###  对redo log、undo log、binlog的了解  

+ binlog（Binary Log）：  二进制日志记录了MySQL所有修改数据库的操作，然后以二进制的形式记录在日志文件中，其中还包括每条语句所执行的时间和所消耗的资源，以及相关的事务信息。  
+ redo log：  重做日志用来实现事务的持久性，由两部分组成：一是内存中的重做日志缓冲（redo log buffer），其是易失的；二是重做日志文件（redo log file），它是持久的。  
+  undo log：如果用户执行的事务或语句由于某种原因失败了，又或者用户用一条ROLLBACK语句请求回滚，就可以利用这些undo信息将数据回滚到修改之前的样子 。

### MySQL主从同步是如何实现的？  

+ 复制（replication）是MySQL数据库提供的一种高可用高性能的解决方案，一般用来建立大型的应用。总体来说，replication的工作原理分为以下3个步骤：  
	+ 主服务器（master）把数据更改记录到二进制日志（binlog）中。
	+ 从服务器（slave）把主服务器的二进制日志复制到自己的中继日志（relay log）中。
	+ 从服务器重做中继日志中的日志，把更改应用到自己的数据库上，以达到数据的最终一致性。

+ 复制的工作原理并不复杂，其实就是一个完全备份加上二进制日志备份的还原。不同的是这个二进制日志的还原操作基本上实时在进行中。这里特别需要注意的是，复制不是完全实时地进行同步，而是异步实时。这中间存在主从服务器之间的执行延时，如果主服务器的压力很大，则可能导致主从服务器延时较大。复制的工作原理如下图所示，其中从服务器有2个线程，一个是I/O线程，负责读取主服务器的二进制日志，并将其保存为中继日志；另一个是SQL线程，复制执行中继日志。  

![image-20230913220320443](../../AppData/Roaming/Typora/typora-user-images/image-20230913220320443.png)



  
